module.exports = gim

var util = require('util')
var Stream = require('stream')
var childProcess = require('child_process')
var debug = require('debug')('gim')

var Duplex = Stream.Duplex
var spawn = childProcess.spawn

util.inherits(gim, Duplex)

module.exports = gim

function gim(source, options) {
  if (!(this instanceof gim))
    return new gim(source, options)

  this.init(source, options)
}

gim.extend = function () {
  function gim(source, options) {
    if (!(this instanceof gim))
      return new gim(source, options)

    this.init(source, options)
  }

  util.inherits(gim, this)

  Object.keys(this).forEach(function (key) {
    gim[key] = this[key]
  }, this)

  return gim
}

gim.prototype.argument =
gim.prototype.arg = function () {
  for (var i = 0; i < arguments.length; i++)
    this.args.push(arguments[i])

  return this
}

gim.prototype.identify = function (string, callback) {
  if (!callback) {
    callback = string
    string = null
  }

  if (typeof callback !== 'function')
    throw TypeError('Callback must be a function.')

  if (string && typeof string !== 'string')
    throw TypeError('String must be a string.')

  var input = this.filename || this.input || '-'

  if (string)
    this.args = ['-format', string, input]
  else
    this.args = ['-verbose', input]

  this.command = 'identify'
  this.spawn()
  this.toString(callback)

  return this
}

gim.prototype.writeFile = function (filename, callback) {
  if (!callback && typeof filename === 'function') {
    callback = filename
    filename = null
  }

  filename = filename
    || this.output

  if (!filename)
    throw TypeError('An output filename must be defined.')

  // Input file at the beginning
  if (this.filename)
    this.args.splice(0, 0, this.filename)

  // Output file at the end
  this.args.push(filename)

  this.spawn()

  var ended = false

  this.on('error', function (err) {
    if (ended)
      return

    ended = true
    callback(err)
  })

  this._proc.on('close', function () {
    if (ended)
      return

    ended = true
    callback()
  })

  return this
}

gim.prototype.exec = function (command, args, callback) {
  if (!callback) {
    if (typeof args === 'function') {
      callback = args
      args = null
    } else if (typeof command === 'function') {
      callback = command
      command = null
    }
  }

  if (Array.isArray(command)) {
    this.args = command
    command = args = null
  }

  if (typeof command === 'string')
    this.command = command

  if (Array.isArray(args))
    this.args = args

  this.spawn()
  this.toString(callback)

  return this
}

gim.prototype.init = function (source, options) {
  if (!options) {
    if (source && source.constructor === Object) {
      this.options = options = source
      source = null
    } else {
      this.options = options = {}
    }
  }

  source = source
    || options.input
    || options.source
    || options.filename
    || options.buffer
    || options.stream

  if (typeof source === 'string')
    this.filename = source
  else if (Buffer.isBuffer(source))
    this.sourceBuffer = source
  else if (source instanceof Stream)
    this.sourceStream = source
  else if (source)
    throw TypeError('Source must be a image file, image buffer, or image readable stream.')

  if (options.output)
    this.output = options.output
  if (typeof options.GraphicsMagick === 'boolean')
    this.GraphicsMagick = options.GraphicsMagick
  else if (typeof options.ImageMagick === 'boolean')
    this.GraphicsMagick = !options.ImageMagick

  this.command = options.command || 'convert'
  this.args = options.args || []
}

gim.prototype.spawn = function () {
  var command = this.command
  var args = this.args

  if (this.GraphicsMagick) {
    args.splice(0, 0, command)
    command = 'gm'
  }

  var proc = this._proc = spawn(command, args)
  debug(command + ' ' + args.join(''))

  proc.on('error', this.emit.bind(this, 'error'))

  var stdin = this._stdin = proc.stdin
  var stdout = this._stdout = proc.stdout

  this._readableState = stdout._readableState
  this._writableState = stdin._writableState

  this.emit('spawn')
  this.spawned = false

  if (this.sourceBuffer)
    stdin.end(this.sourceBuffer)
  else if (this.sourceStream)
    this.sourceStream.pipe(stdin)

  return this
}

gim.prototype.toString = function (callback) {
  return gim.toString(this, callback)
}

gim.prototype.addListener =
gim.prototype.on = function (event, fn) {
  switch (event) {
    case 'data':
    case 'end':
    case 'readable':
      return this._stdout.on(event, fn)
    case 'drain':
    case 'finish':
      return this._stdin.on(event, fn)
    default:
      return Duplex.prototype.on.call(this, event, fn)
  }
}

gim.prototype.pipe = function (dest, opts) {
  return this._stdout.pipe(dest, opts)
}

gim.prototype.setEncoding = function (enc) {
  return this._stdout.setEncoding(enc)
}

gim.prototype.read = function (size) {
  return this._stdout.read(size)
}

gim.prototype.end = function (chunk, enc, cb) {
  return this._stdin.end(chunk, enc, cb)
}

gim.prototype.write = function (chunk, enc, cb) {
  return this._stdin.write(chunk, enc, cb)
}

// Utilities
gim.toString = function (stream, callback) {
  var buf = ''

  stream.setEncoding('utf8')
  stream.on('data', function (chunk) {
    buf += chunk
  })
  stream.once('end', function () {
    callback(null, buf)
  })
  stream.once('error', callback)

  return stream
}